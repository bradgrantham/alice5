{
    "Shader": {
        "info": {
            "date": "1459916847",
            "description": "Arrow keys to move. SPACE bar to restart.",
            "flags": 48,
            "hasliked": 0,
            "id": "Ms3XWN",
            "likes": 212,
            "name": "Pacman Game",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "game",
                "pacman"
            ],
            "username": "iq",
            "viewed": 25314
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// postprocess (thanks to Timothy Lottes for the CRT filter - https://www.shadertoy.com/view/XsjSzR)\n\n\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\nvec2 cell2ndc( vec2 c )\n{\n\tc = (c+0.5) / 31.0;\n    c.x -= 0.5*(1.0-iResolution.x/iResolution.y); // center\n    return c;\n}\n\n\nvec3 drawMap( vec3 col, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n    p.x += 0.5*(1.0-iResolution.x/iResolution.y); // center\n    float wp = 1.0/iResolution.y;\n\n    p *= 31.0;\n    vec2 q = floor(p);\n    vec2 r = fract(p);\n    float wr = 31.0*wp;\n\n    if( q.x>=0.0 && q.x<=27.0 )\n    {\n        float c = texture( iChannel0, (q+0.5)/iResolution.xy, -100.0 ).x;\n\n        // points\n        if( abs(c-2.0)<0.5 )\n        {\n            float d = sdCircle(r-0.5, 0.15);\n            col += 0.3*vec3(1.0,0.7,0.4)*exp(-22.0*d*d); // glow\n        }\n    }\n    \n\t// balls\n    \n    vec2 bp[4];\n    \n    bp[0] = vec2( 1.0, 7.0) + 0.5;\n    bp[1] = vec2(25.0, 7.0) + 0.5;\n    bp[2] = vec2( 1.0,27.0) + 0.5;\n    bp[3] = vec2(25.0,27.0) + 0.5;\n    \n    for( int i=0; i<4; i++ )\n    {\n        float c = texture( iChannel0, (bp[i]+0.5)/iResolution.xy, -100.0 ).x;\n        if( abs(c-3.0)<0.5 )\n        {\n        float d = length(p - bp[i]);\n        col += 0.35*vec3(1.0,0.7,0.4)*exp(-1.0*d*d)*smoothstep( -1.0, -0.5, sin(2.0*6.2831*iTime) );\n        }\n    }\n    \n    return col;\n}\n\n\nvec3 drawPacman( vec3 col, in vec2 fragCoord, in vec4 pacmanPos, in vec3 pacmanMovDirNex )\n{\n    vec2 off = dir2dis(pacmanMovDirNex.x);\n    \n    vec2 mPacmanPos = pacmanPos.xy;\n    //vec2 mPacmanPos = pacmanPos.xy + off*pacmanPos.z*pacmanPos.w;\n\n    vec2 p = fragCoord/iResolution.y;\n    float eps = 1.0 / iResolution.y;\n\n    vec2 q = p - cell2ndc( mPacmanPos );\n\n    float c = max(0.0,sdCircle(q, 0.023));\n\n    // glow\n    col += 0.25*vec3(1.0,0.8,0.0)*exp(-400.0*c*c);\n\n    return col;\n}\n\nvec3 drawGhost( vec3 col, in vec2 fragCoord, in vec3 pos, in float dir, in float id, in vec3 mode )\n{\n    vec2 off = dir2dis(dir);\n\n    vec2 gpos = pos.xy;\n\n    vec2 p = fragCoord/iResolution.y;\n    float eps = 1.0 / iResolution.y;\n\n    vec2 q = p - cell2ndc( gpos );\n\n    float c = max(0.0,sdCircle(q, 0.023));\n   \n    vec3 gco = 0.5 + 0.5*cos( 5.0 + 0.7*id + vec3(0.0,2.0,4.0) );\n    float g = mode.x;\n    if( mode.z>0.75 )\n    {\n        g *= smoothstep(-0.2,0.0,sin(3.0*6.28318*(iTime-mode.y)));\n    }\n    gco = mix( gco, vec3(0.1,0.5,1.0), g );\n\n    // glow\n    col += 0.2*gco*exp(-300.0*c*c);\n\n    return col;\n}\n\nvec3 drawScore( in vec3 col, in vec2 fragCoord, vec2 score, float lives )\n{\n    // score\n    vec2 p = fragCoord/iResolution.y;\n    // lives\n    float eps = 1.0 / iResolution.y;\n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i);\n        vec2 q = p - vec2(0.1 + 0.075*h, 0.7 );\n        if( h + 0.5 < lives )\n        {\n            float c = max(0.0,sdCircle(q, 0.023));\n\n            col += 0.17*vec3(1.0,0.8,0.0)*exp(-1500.0*c*c);\n        }\n    }\n\n    return col;\n}\n\n//============================================================\n\n//\n// PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n//\n//   by Timothy Lottes\n//\n// This is more along the style of a really good CGA arcade monitor.\n// With RGB inputs instead of NTSC.\n// The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n//\n// Left it unoptimized to show the theory behind the algorithm.\n//\n// It is an example what I personally would want as a display option for pixel art games.\n// Please take and use, change, or whatever.\n//\n\n// Emulated input resolution.\n\n//vec2 res = 640.0*vec2(1.0,iResolution.y/iResolution.x);\n#define res (iResolution.xy/floor(1.0+iResolution.xy/512.0))\n\n// Hardness of scanline.\n//  -8.0 = soft\n// -16.0 = medium\nconst float hardScan=-8.0;\n\n// Hardness of pixels in scanline.\n// -2.0 = soft\n// -4.0 = hard\nconst float hardPix=-3.0;\n\n// Display warp.\n// 0.0 = none\n// 1.0/8.0 = extreme\nconst vec2 warp=vec2(1.0/32.0,1.0/24.0); \n\n// Amount of shadow mask.\nconst float maskDark=0.6;\nconst float maskLight=2.0;\n\n//------------------------------------------------------------------------\n\n// sRGB to Linear.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\n\n// Linear to sRGB.\n// Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n// Nearest emulated sample given floating point position and texel offset.\n// Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off){\n  pos=floor(pos*res+off)/res;\n  if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);\n  return ToLinear(texture(iChannel1,pos.xy,-16.0).rgb);}\n\n// Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}\n    \n// 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n// 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off){\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  // Return filtered sample.\n  return (b*wb+c*wc+d*wd)/(wb+wc+wd);}\n\n// 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off){\n  vec3 a=Fetch(pos,vec2(-2.0,off));\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  vec3 e=Fetch(pos,vec2( 2.0,off));\n  float dst=Dist(pos).x;\n  // Convert distance to weight.\n  float scale=hardPix;\n  float wa=Gaus(dst-2.0,scale);\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  float we=Gaus(dst+2.0,scale);\n  // Return filtered sample.\n  return (a*wa+b*wb+c*wc+d*wd+e*we)/(wa+wb+wc+wd+we);}\n\n// Return scanline weight.\nfloat Scan(vec2 pos,float off){\n  float dst=Dist(pos).y;\n  return Gaus(dst+off,hardScan);}\n\n// Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos){\n  vec3 a=Horz3(pos,-1.0);\n  vec3 b=Horz5(pos, 0.0);\n  vec3 c=Horz3(pos, 1.0);\n  float wa=Scan(pos,-1.0);\n  float wb=Scan(pos, 0.0);\n  float wc=Scan(pos, 1.0);\n  return a*wa+b*wb+c*wc;}\n\n\n// Shadow mask.\nvec3 Mask(vec2 pos)\n{\n  pos.x+=pos.y*3.0;\n  vec3 mask=vec3(maskDark,maskDark,maskDark);\n  pos.x=fract(pos.x/6.0);\n  if(pos.x<0.333)mask.r=maskLight;\n  else if(pos.x<0.666)mask.g=maskLight;\n  else mask.b=maskLight;\n  return mask;}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------\n    // CRT\n    //------------------------\n    vec3 col = ToSrgb( Tri(fragCoord.xy/iResolution.xy)*Mask(fragCoord.xy) );\n    //col = texture( iChannel1, fragCoord.xy/iResolution.xy ).xyz;\n\n    //------------------------\n    // glow\n    //------------------------\n       \n    vec4  pacmanPos = loadValue( txPacmanPos );\n    vec3  pacmanDir = loadValue( txPacmanMovDirNex ).xyz;\n    vec4  ghostPos[4];\n    ghostPos[0]     = loadValue( txGhost0PosDir );\n    ghostPos[1]     = loadValue( txGhost1PosDir );\n    ghostPos[2]     = loadValue( txGhost2PosDir );\n    ghostPos[3]     = loadValue( txGhost3PosDir );\n    vec2  points    = loadValue( txPoints ).xy;\n    float state     = loadValue( txState ).x;\n    float lives     = loadValue( txLives ).x;\n    vec3 mode       = loadValue( txMode ) .xyz;\n\n    // map\n    col = drawMap( col, fragCoord );\n\n    // pacman\n    col = drawPacman( col, fragCoord, pacmanPos, pacmanDir );\n\n    // ghosts\n    for( int i=0; i<4; i++ )\n        col = drawGhost( col, fragCoord, ghostPos[i].xyz, ghostPos[i].w, float(i), mode );\n    \n    // score\n    col = drawScore( col, fragCoord, points, lives );\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "codefile": "Image.frag",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// game play\n\n#define _ 0 // empty\n#define W 1 // wall\n#define P 2 // point\n#define B 3 // ball\n#define PA(a,b,c,d,e,f,g) (a+4*(b+4*(c+4*(d+4*(e+4*(f+4*(g)))))))\n#define DD(id,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) if(y==id) m=(x<7)?PA(c0,c1,c2,c3,c4,c5,c6):PA(c7,c8,c9,c10,c11,c12,c13);\nint map( in ivec2 q ) \n{\n    if( q.x>13 ) q.x = q.x = 26-q.x;\n\tint x = q.x;\n\tint y = q.y;\n\tint m = 0;\n    DD(30, W,W,W,W,W,W,W,W,W,W,W,W,W,W)\n    DD(29, W,P,P,P,P,P,P,P,P,P,P,P,P,W)\n    DD(28, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(27, W,B,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(26, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(25, W,P,P,P,P,P,P,P,P,P,P,P,P,P)\n    DD(24, W,P,W,W,W,W,P,W,W,P,W,W,W,W)\n    DD(23, W,P,W,W,W,W,P,W,W,P,W,W,W,W)\n    DD(22, W,P,P,P,P,P,P,W,W,P,P,P,P,W)\n    DD(21, W,W,W,W,W,W,P,W,W,W,W,W,_,W)\n    DD(20, _,_,_,_,_,W,P,W,W,W,W,W,_,W)\n    DD(19, _,_,_,_,_,W,P,W,W,_,_,_,_,_)\n    DD(18, _,_,_,_,_,W,P,W,W,_,W,W,W,_)\n    DD(17, W,W,W,W,W,W,P,W,W,_,W,_,_,_)\n    DD(16, _,_,_,_,_,_,P,_,_,_,W,_,_,_)\n    DD(15, W,W,W,W,W,W,P,W,W,_,W,_,_,_)\n    DD(14, _,_,_,_,_,W,P,W,W,_,W,W,W,W)\n    DD(13, _,_,_,_,_,W,P,W,W,_,_,_,_,_)\n    DD(12, _,_,_,_,_,W,P,W,W,_,W,W,W,W)\n    DD(11, W,W,W,W,W,W,P,W,W,_,W,W,W,W)\n    DD(10, W,P,P,P,P,P,P,P,P,P,P,P,P,W)\n    DD( 9, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD( 8, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD( 7, W,B,P,P,W,W,P,P,P,P,P,P,P,_)\n    DD( 6, W,W,W,P,W,W,P,W,W,P,W,W,W,W)\n    DD( 5, W,W,W,P,W,W,P,W,W,P,W,W,W,W)\n    DD( 4, W,P,P,P,P,P,P,W,W,P,P,P,P,W)\n    DD( 3, W,P,W,W,W,W,W,W,W,W,W,W,P,W)\n    DD( 2, W,P,W,W,W,W,W,W,W,W,W,W,P,W)\n    DD( 1, W,P,P,P,P,P,P,P,P,P,P,P,P,P)\n    DD( 0, W,W,W,W,W,W,W,W,W,W,W,W,W,W)\n\treturn (m>>(2*(x%7))) & 3;\n}\n\n//----------------------------------------------------------------------------------------------\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float speedPacman = 7.0;\nconst float speedGhost  = 6.0;\nconst float intelligence = 0.53;\nconst float modeTime = 5.0;\n//----------------------------------------------------------------------------------------------\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    vec2 r = 0.5*vec2(re.zw);\n    vec2 d = abs( vec2(fragCoord-re.xy)-r) - r - 0.5;\n    fragColor = ( -max(d.x,d.y) > 0.0 ) ? va : fragColor;\n}\n\nivec2 dir2dis( in int dir )\n{\n    ivec2 off = ivec2(0,0);\n         if( dir==0 ) { off = ivec2( 0, 0); }\n    else if( dir==1 ) { off = ivec2( 1, 0); }\n    else if( dir==2 ) { off = ivec2(-1, 0); }\n    else if( dir==3 ) { off = ivec2( 0, 1); }\n    else              { off = ivec2( 0,-1); }\n    return off;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n\n    // don't compute gameplay outside of the data area\n    if( ifragCoord.x > 31 || ifragCoord.y>31 ) discard;\n    \n    //---------------------------------------------------------------------------------   \n\t// load game state\n\t//---------------------------------------------------------------------------------\n    vec4  ghostPos[4];\n    vec4  pacmanPos       = loadValue( txPacmanPos );\n    vec3  pacmanMovDirNex = loadValue( txPacmanMovDirNex ).xyz;\n    vec2  points          = loadValue( txPoints ).xy;\n    float state           = loadValue( txState ).x; // -1 = start game, 0 = start life, 1 = playing, 2 = game over\n    vec3  mode            = loadValue( txMode ).xyz;\n    float lives           = loadValue( txLives ).x;\n    int   cell            = int( loadValue( ifragCoord ).x );\n    ghostPos[0]           = loadValue( txGhost0PosDir );\n    ghostPos[1]           = loadValue( txGhost1PosDir );\n    ghostPos[2]           = loadValue( txGhost2PosDir );\n    ghostPos[3]           = loadValue( txGhost3PosDir );\n\t\n    //---------------------------------------------------------------------------------\n    // reset\n\t//---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\n    if( state<0.5 )\n    {\n        pacmanPos       = vec4(13.0,13.0,0.0,0.0);\n        pacmanMovDirNex = vec3(0.0,0.0,0.0);\n        mode            = vec3(0.0,-100.0,0.0);\n        ghostPos[0]     = vec4(13.0,19.0,0.0,1.0);\n        ghostPos[1]     = vec4(13.0,17.0,0.0,1.0);\n        ghostPos[2]     = vec4(12.0,16.0,0.0,1.0);\n        ghostPos[3]     = vec4(14.0,15.0,0.0,1.0);\n    }\n    \n    if( state < -0.5 )\n    {\n        state           = 0.0;\n        points          = vec2(0.0,0.0);\n        lives           = 3.0;\n        if( ifragCoord.x<27 && ifragCoord.y<31 ) \n            cell = map( ifragCoord );\n    }\n    else if( state < 0.5 )\n    {\n        state = 1.0;\n    }\n    else if( state < 1.5 ) \n\t{\n        //-------------------\n        // pacman\n        //-------------------\n\n        // move with keyboard\n        if( texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x>0.5 ) pacmanMovDirNex.z = 1.0;\n        if( texelFetch( iChannel1, ivec2(KEY_LEFT, 0), 0 ).x>0.5 ) pacmanMovDirNex.z = 2.0;\n        if( texelFetch( iChannel1, ivec2(KEY_UP,   0), 0 ).x>0.5 ) pacmanMovDirNex.z = 3.0;\n        if( texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0 ).x>0.5 ) pacmanMovDirNex.z = 4.0;\n\n        // execute desired turn as soon as possible\n        if( pacmanMovDirNex.z>0.5 && abs(loadValue( ivec2(pacmanPos.xy) + dir2dis(int(pacmanMovDirNex.z)) ).x-float(W))>0.25 )\n        {\n            pacmanMovDirNex = vec3( pacmanMovDirNex.zz, 0.0 );\n        }\n        \n        \n        if( pacmanMovDirNex.x>0.5 ) pacmanPos.z += iTimeDelta*speedPacman;\n\n        ivec2 off = dir2dis(int(pacmanMovDirNex.x));\n        ivec2 np = ivec2(pacmanPos.xy) + off;\n        float c = loadValue( np ).x;\n        pacmanPos.w = step( 0.25, abs(c-float(W)) );\n\n                \n        if( pacmanPos.z>=1.0 )\n        {\n            pacmanPos.z = 0.0;\n            float c = loadValue( np ).x;\n\n            if( abs(c-float(W))<0.25 )\n            {\n                pacmanMovDirNex.x = 0.0;\n            }\n            else\n            {\n                pacmanPos.xy += vec2(off);\n                // tunnel!\n                     if( pacmanPos.x< 0.0 ) pacmanPos.x=26.0;\n                else if( pacmanPos.x>26.0 ) pacmanPos.x= 0.0;\n            }\n\n            bool isin = (ifragCoord.x==int(pacmanPos.x)) && (ifragCoord.y==int(pacmanPos.y));\n            c = loadValue( ivec2(pacmanPos.xy) ).x;\n            if( abs(c-float(P))<0.2 )\n            {\n                if( isin ) cell = _;\n                points += vec2(10.0,1.0);\n            }\n            else if( abs(c-float(B))<0.2 )\n            {\n                if( isin ) cell = _;\n                points += vec2(50.0,1.0);\n                mode.x = 1.0;\n                mode.y = iTime;\n            }\n            if( points.y>241.5 )\n            {\n                state = 2.0;\n            }\n        }\n        \n        //-------------------\n        // ghost\n        //-------------------\n\n        for( int i=0; i<4; i++ )\n        {\n            float seed = float(iFrame)*13.1 + float(i)*17.43;\n\n            ghostPos[i].z += iTimeDelta*speedGhost;\n\n            if( ghostPos[i].z>=1.0 )\n            {\n                ghostPos[i].z = 0.0;\n\n                float c = loadValue( ivec2(ghostPos[i].xy)+dir2dis(int(ghostPos[i].w)) ).x;\n\n                bool wr = int(loadValue( ivec2(ghostPos[i].xy)+ivec2( 1, 0) ).x) == W;\n                bool wl = int(loadValue( ivec2(ghostPos[i].xy)+ivec2(-1, 0) ).x) == W;\n                bool wu = int(loadValue( ivec2(ghostPos[i].xy)+ivec2( 0, 1) ).x) == W;\n                bool wd = int(loadValue( ivec2(ghostPos[i].xy)+ivec2( 0,-1) ).x) == W;\n\n                vec2 ra = vec2( hash( seed + 0.0),\n                                hash( seed + 11.57) );\n                if( abs(c-float(W)) < 0.25) // found a wall on the way\n                {\n                    if( ghostPos[i].w < 2.5 ) // was moving horizontally\n                    {\n                             if( !wu &&  wd )                ghostPos[i].w = 3.0;\n                        else if(  wu && !wd )                ghostPos[i].w = 4.0;\n                        else if( pacmanPos.y>ghostPos[i].y ) ghostPos[i].w = 3.0+mode.x;\n                        else if( pacmanPos.y<ghostPos[i].y ) ghostPos[i].w = 4.0-mode.x;\n                        else                                 ghostPos[i].w = 3.0-ghostPos[i].w;\n                    }\n                    else                          // was moving vertically\n                    {\n                             if( !wr &&  wl )                ghostPos[i].w = 1.0;\n                        else if(  wr && !wl )                ghostPos[i].w = 2.0;\n                        else if( pacmanPos.x>ghostPos[i].x ) ghostPos[i].w = 1.0+mode.x;\n                        else if( pacmanPos.x<ghostPos[i].x ) ghostPos[i].w = 2.0-mode.x;\n                        else                                 ghostPos[i].w = 7.0-ghostPos[i].w;\n                    }\n\n                }\n                else if( ra.x < intelligence ) // found an intersection and it decided to find packman\n                {\n                    if( ghostPos[i].w < 2.5 ) // was moving horizontally\n                    {\n                             if( !wu && pacmanPos.y>ghostPos[i].y ) ghostPos[i].w = 3.0;\n                        else if( !wd && pacmanPos.y<ghostPos[i].y ) ghostPos[i].w = 4.0;\n                    }\n                    else                          // was moving vertically\n                    {\n                             if( !wr && pacmanPos.x>ghostPos[i].x ) ghostPos[i].w = 1.0;\n                        else if( !wl && pacmanPos.x<ghostPos[i].x ) ghostPos[i].w = 2.0;\n                    }\n                }\n                else\n                {\n                         if( ra.y<0.15 ) { if( !wr ) ghostPos[i].w = 1.0; }\n                    else if( ra.y<0.30 ) { if( !wl ) ghostPos[i].w = 2.0; }\n                    else if( ra.y<0.45 ) { if( !wu ) ghostPos[i].w = 3.0; }\n                    else if( ra.y<0.60 ) { if( !wd ) ghostPos[i].w = 4.0; }\n                }\n\n                if( abs(ghostPos[i].x-13.0)<0.25 &&\n                    abs(ghostPos[i].y-19.0)<0.25 && \n                    abs(ghostPos[i].w-4.0)<0.25 )\n                {\n                    ghostPos[i].w = 1.0;\n                }\n                \n                ghostPos[i].xy += vec2(dir2dis(int(ghostPos[i].w)));\n                    \n                    // tunnel!\n                     if( ghostPos[i].x< 0.0 ) ghostPos[i].x=26.0;\n                else if( ghostPos[i].x>26.0 ) ghostPos[i].x= 0.0;\n            }\n            \n            \n            // collision\n            if( abs(pacmanPos.x-ghostPos[i].x)<0.5 && abs(pacmanPos.y-ghostPos[i].y)<0.5 )\n            {\n                if( mode.x<0.5 )\n                {\n                    lives -= 1.0;\n                    if( lives<0.5 )\n                    {\n                \t\tstate = 2.0;\n                    }\n                    else\n                    {\n                        state = 0.0;\n                    }\n                }\n                else\n                {\n                    points.x += 200.0;\n                    ghostPos[i] = vec4(13.0,19.0,0.0,1.0);\n                }\n            }\n        }\n \n        //-------------------\n        // mode\n        //-------------------\n        mode.z = (iTime-mode.y)/modeTime;\n        if( mode.x>0.5 && mode.z>1.0 )\n        {\n            mode.x = 0.0;\n        }\n    }\n    else //if( state > 0.5 )\n    {\n        float pressSpace = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n  \n\t//---------------------------------------------------------------------------------\n\t// store game state\n\t//---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    \n    storeValue( txPacmanPos,        vec4(pacmanPos),             fragColor, ifragCoord );\n    storeValue( txPacmanMovDirNex,  vec4(pacmanMovDirNex,0.0),   fragColor, ifragCoord );\n    storeValue( txGhost0PosDir,     vec4(ghostPos[0]),           fragColor, ifragCoord );\n    storeValue( txGhost1PosDir,     vec4(ghostPos[1]),           fragColor, ifragCoord );\n    storeValue( txGhost2PosDir,     vec4(ghostPos[2]),           fragColor, ifragCoord );\n    storeValue( txGhost3PosDir,     vec4(ghostPos[3]),           fragColor, ifragCoord );\n    storeValue( txPoints,           vec4(points,0.0,0.0),        fragColor, ifragCoord );\n    storeValue( txState,            vec4(state,0.0,0.0,0.0),     fragColor, ifragCoord );\n    storeValue( txMode,             vec4(mode,0.0),              fragColor, ifragCoord );\n    storeValue( txLives,            vec4(lives,0.0,0.0,0.0),     fragColor, ifragCoord );\n    storeValue( txCells,            vec4(cell,0.0,0.0,0.0),      fragColor, ifragCoord );\n}",
                "codefile": "Buffer A.frag",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n// rendering\n\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec2 p, vec2 a, vec2 b )\n{\n  p -= (a+b)*0.5;\n  vec2 d = abs(p) - 0.5*(b-a);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\n//============================================================\n\n// digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n// converted to LUT and integer logic by iq\nconst int[] font = int[]( \n    7 + 5*16 + 5*256 + 5*4096 + 7*65536,\n    2 + 2*16 + 2*256 + 2*4096 + 2*65536,\n    7 + 1*16 + 7*256 + 4*4096 + 7*65536,\n    7 + 4*16 + 7*256 + 4*4096 + 7*65536,\n    4 + 7*16 + 5*256 + 1*4096 + 1*65536,\n    7 + 4*16 + 7*256 + 1*4096 + 7*65536,\n    7 + 5*16 + 7*256 + 1*4096 + 7*65536,\n    4 + 4*16 + 4*256 + 4*4096 + 7*65536,\n    7 + 5*16 + 7*256 + 5*4096 + 7*65536,\n    7 + 4*16 + 7*256 + 5*4096 + 7*65536 );\n                          \nint SampleDigit(const in int n, const in vec2 vUV)\n{\n    //if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0;\n    vec2 q = abs(vUV-0.5);\n    if( max(q.x,q.y)>0.5 ) return 0;\n    \n\n    ivec2 p = ivec2(floor(vUV * vec2(4.0, 5.0)));\n    int   i = p.x + p.y*4;\n    \n    return (font[n]>>i) & 1;\n}\n\nint PrintInt( in vec2 uv, in int value )\n{\n    int res = 0;\n    \n    int maxDigits = (value<10) ? 1 : (value<100) ? 2 : 3;\n    int digitID = maxDigits - 1 - int(floor(uv.x));\n    \n    if( digitID>=0 && digitID<maxDigits )\n    {\n        int div = (digitID==0) ? 1 : (digitID==1) ? 10 : 100;\n        res = SampleDigit( (value/div) % 10, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\n//============================================================\n\nvec3 drawMap( vec3 col, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.y;\n    p.x += 0.5*(1.0-iResolution.x/iResolution.y); // center\n    float wp = 1.0/iResolution.y;\n\n    vec2 q = floor(p*31.0);\n    vec2 r = fract(p*31.0);\n    float wr = 31.0*wp;\n\n    if( q.x>=0.0 && q.x<=27.0 )\n    {\n        float c = texture( iChannel0, (q+0.5)/iResolution.xy, -100.0 ).x;\n\n        // empty\n        if( c<0.5 )\n        {\n        }\n        // walls\n        else if( c<1.5 )\n        {\n            vec2 wmi = vec2( texture( iChannel0, (q-vec2(1.0,0.0)+0.5)/iResolution.xy ).x,\n                             texture( iChannel0, (q-vec2(0.0,1.0)+0.5)/iResolution.xy ).x );\n            vec2 wma = vec2( texture( iChannel0, (q+vec2(1.0,0.0)+0.5)/iResolution.xy ).x,\n                             texture( iChannel0, (q+vec2(0.0,1.0)+0.5)/iResolution.xy ).x );\n\t\t\t\n            wmi = step( abs(wmi-1.0), vec2(0.25) );\n            wma = step( abs(wma-1.0), vec2(0.25) );\n            vec2 ba = -(0.16+0.35*wmi);\n            vec2 bb =  (0.16+0.35*wma);\n\n            //bb = vec2(0.51); ba = -bb;\n\n            float d = sdBox(r-0.5, ba, bb);\n            float f = 1.0 - smoothstep( -0.01, 0.01, d );\n            \n            vec3 wco = 0.5 + 0.5*cos( 3.9 - 0.2*(wmi.x+wmi.y+wma.x+wma.y) + vec3(0.0,1.0,1.5) );\n            wco += 0.1*sin(40.0*d);\n            col = mix( col, wco, f );\n        }\n        // points\n        else if( c<2.5 )\n        {\n            float d = sdCircle(r-0.5, 0.15);\n            float f = 1.0 - smoothstep( -wr, wr, d );\n            col = mix( col, vec3(1.0,0.8,0.7), f );\n            //col += 0.3*vec3(1.0,0.7,0.4)*exp(-12.0*d*d); // glow\n        }\n        // big alls\n        else\n        {\n            float d = sdCircle( r-0.5 ,0.40*smoothstep( -1.0, -0.5, sin(2.0*6.2831*iTime) ));\n            float f = 1.0 - smoothstep( -wr, wr, d );\n            col = mix( col, vec3(1.0,0.9,0.5), f );\n        }\n    }\n    \n    return col;\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\n\nvec2 cell2ndc( vec2 c )\n{\n\tc = (c+0.5) / 31.0;\n    c.x -= 0.5*(1.0-iResolution.x/iResolution.y); // center\n    return c;\n}\n\n\nvec3 drawPacman( vec3 col, in vec2 fragCoord, in vec4 pacmanPos, in vec3 pacmanMovDirNex )\n{\n    vec2 off = dir2dis(pacmanMovDirNex.x);\n    \n    vec2 mPacmanPos = pacmanPos.xy;\n    //vec2 mPacmanPos = pacmanPos.xy + off*pacmanPos.z*pacmanPos.w;\n\n    vec2 p = fragCoord/iResolution.y;\n    float eps = 1.0 / iResolution.y;\n\n    vec2 q = p - cell2ndc( mPacmanPos );\n\n         if( pacmanMovDirNex.y<1.5 ) { q = q.xy*vec2(-1.0,1.0); }\n    else if( pacmanMovDirNex.y<2.5 ) { q = q.xy; }\n    else if( pacmanMovDirNex.y<3.5 ) { q = q.yx*vec2(-1.0,1.0); }\n    else                             { q = q.yx; }\n\n    float c = sdCircle(q, 0.023);\n    float f = c;\n\n    if( pacmanMovDirNex.y>0.5 )\n    {\n        float an = (0.5 + 0.5*sin(4.0*iTime*6.2831)) * 0.9;\n        vec2 w = normalize( q - vec2(0.005,0.0) );\n\n        w = vec2( w.x, abs( w.y ) );\n        float m = dot( w, vec2(sin(an),cos(an)));\n        f = max( f, -m );\n    }\n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, vec3(1.0,0.8,0.1), f );\n\n    // glow\n    //col += 0.25*vec3(1.0,0.8,0.0)*exp(-300.0*c*c);\n\n    return col;\n}\n\nvec3 drawGhost( vec3 col, in vec2 fragCoord, in vec3 pos, in float dir, in float id, in vec3 mode )\n{\n    vec2 off = dir2dis(dir);\n\n    vec2 gpos = pos.xy;\n\n    \n    vec2 p = fragCoord/iResolution.y;\n    float eps = 1.0 / iResolution.y;\n\n    vec2 q = p - cell2ndc( gpos );\n\n    float c = sdCircle(q, 0.023);\n    float f = c;\n\tf = max(f,-q.y);\n    float on = 0.0025*sin(1.0*6.28318*q.x/0.025 + 6.2831*iTime);\n    f = min( f, sdBox(q-vec2(0.0,-0.0065+on), vec2(0.023,0.012) ) );\n   \n    vec3 gco = 0.5 + 0.5*cos( 5.0 + 0.7*id + vec3(0.0,2.0,4.0) );\n    float g = mode.x;\n    if( mode.z>0.75 )\n    {\n        g *= smoothstep(-0.2,0.0,sin(3.0*6.28318*(iTime-mode.y)));\n    }\n    gco = mix( gco, vec3(0.1,0.5,1.0), g );\n    \n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, gco, f );\n\n    f = sdCircle( vec2(abs(q.x-off.x*0.006)-0.011,q.y-off.y*0.006-0.008), 0.008);\n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, vec3(1.0), f );\n\n    f = sdCircle( vec2(abs(q.x-off.x*0.01)-0.011,q.y-off.y*0.01-0.008), 0.004);\n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, vec3(0.0), f );\n\n    // glow\n    //col += 0.2*gco*exp(-300.0*c*c);\n\n    return col;\n}\n\n\nvec3 drawScore( in vec3 col, in vec2 fragCoord, vec2 score, float lives )\n{\n    // score\n    vec2 p = fragCoord/iResolution.y;\n    col += float( PrintInt( (p - vec2(0.05,0.9))*20.0, int(score.x) ));\n    col += float( PrintInt( (p - vec2(0.05,0.8))*20.0, int(242.0-score.y) ));\n    \n    // lives\n    float eps = 1.0 / iResolution.y;\n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i);\n        vec2 q = p - vec2(0.1 + 0.075*h, 0.7 );\n        if( h + 0.5 < lives )\n        {\n            float c = sdCircle(q, 0.023);\n            float f = c;\n\n            {\n                vec2 w = normalize( q - vec2(0.005,0.0) );\n                w = vec2( w.x, abs( w.y ) );\n                float an = 0.5;\n                float m = dot( w, vec2(sin(an),cos(an)));\n                f = max( f, -m );\n            }\n            f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n            col = mix( col, vec3(1.0,0.8,0.1), f );\n\n            // glow\n            //col += 0.15*vec3(1.0,0.8,0.0)*exp(-1500.0*c*c);\n        }\n    }\n\n    return col;\n}\n\n//============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------\n    // load game state\n    //------------------------\n       \n    vec4  pacmanPos = loadValue( txPacmanPos );\n    vec3  pacmanDir = loadValue( txPacmanMovDirNex ).xyz;\n    vec4  ghostPos[4];\n    ghostPos[0]     = loadValue( txGhost0PosDir );\n    ghostPos[1]     = loadValue( txGhost1PosDir );\n    ghostPos[2]     = loadValue( txGhost2PosDir );\n    ghostPos[3]     = loadValue( txGhost3PosDir );\n    vec2  points    = loadValue( txPoints ).xy;\n    float state     = loadValue( txState ).x;\n    float lives     = loadValue( txLives ).x;\n    vec3 mode       = loadValue( txMode ) .xyz;\n\n\n    //------------------------\n    // render\n    //------------------------\n    vec3 col = vec3(0.0);\n    \n    // map\n    col = drawMap( col, fragCoord );\n    \n    // pacman\n    col = drawPacman( col, fragCoord, pacmanPos, pacmanDir );\n\n    // ghosts\n    for( int i=0; i<4; i++ )\n    {\n        col = drawGhost( col, fragCoord, ghostPos[i].xyz, ghostPos[i].w, float(i), mode );\n    }\n\n    // score\n    col = drawScore( col, fragCoord, points, lives );\n \n    \n    if( state>1.5 )\n    {\n        col = mix( col, vec3(0.3), smoothstep(-1.0,1.0,sin(2.0*6.2831*iTime)) );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}",
                "codefile": "Buffer B.frag",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst ivec2 txPacmanPos       = ivec2(31, 1);\nconst ivec2 txPacmanMovDirNex = ivec2(31, 3);\nconst ivec2 txPoints          = ivec2(31, 5);\nconst ivec2 txState           = ivec2(31, 7);\nconst ivec2 txGhost0PosDir    = ivec2(31, 9);\nconst ivec2 txGhost1PosDir    = ivec2(31,11);\nconst ivec2 txGhost2PosDir    = ivec2(31,13);\nconst ivec2 txGhost3PosDir    = ivec2(31,15);\nconst ivec2 txMode            = ivec2(31,17);\nconst ivec2 txLives           = ivec2(31,19);\nconst ivec4 txCells           = ivec4(0,0,27,31);",
                "codefile": "Common.frag",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}